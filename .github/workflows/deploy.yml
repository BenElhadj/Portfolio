name: Deploy to GitHub Pages

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  deploy:
    environment:
      name: github-pages
    runs-on: ubuntu-latest
    
    # Ã‰TAPE CLÃ‰: DÃ©finir TOUTES les variables d'environnement disponibles
    # Cela permet Ã  printenv de les voir
    env:
      # Ces variables seront automatiquement disponibles via printenv
      # sans avoir Ã  les lister une par une
      INJECT_ALL_ENV_VARS: true
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.12.0

      - name: Create initial .env.production
        run: |
          # CrÃ©e le fichier .env.production initial
          if [ -f .env ]; then
            cp .env .env.production
          else
            touch .env.production
          fi

      - name: Auto-inject ALL environment variables (VITE_* only)
        run: |
          echo "ðŸš€ Auto-injecting ALL VITE_* variables from ALL sources..."
          echo "Priority: Environment variables (which include GitHub vars/secrets) â†’ printenv"
          echo ""
          
          # Cette fonction reproduit EXACTEMENT la logique de votre script original
          # mais de maniÃ¨re automatique
          auto_inject_vite_vars() {
            echo "Step 1: Collecting all VITE_* variables..."
            
            # RÃ©cupÃ©rer TOUTES les variables d'environnement disponibles
            # Note: GitHub Actions injecte automatiquement:
            # - Les variables de l'environnement 'github-pages'
            # - Les variables du repository (si configurÃ©es pour Ãªtre exposÃ©es)
            # - Les secrets (si configurÃ©s pour Ãªtre exposÃ©s)
            
            # Compter le nombre total de variables VITE_*
            TOTAL_VITE=$(printenv | grep -c '^VITE_' || true)
            echo "Found $TOTAL_VITE VITE_* variable(s) in environment"
            
            # Liste pour stocker toutes les clÃ©s VITE_* uniques
            declare -A ALL_VITE_KEYS
            
            # 1. Ajouter toutes les variables dÃ©tectÃ©es via printenv
            printenv | grep '^VITE_' | cut -d'=' -f1 | while read -r key; do
              ALL_VITE_KEYS["$key"]=1
            done
            
            # 2. Liste des clÃ©s attendues (pour s'assurer qu'elles sont toujours traitÃ©es)
            # Vous pouvez modifier cette liste si besoin, mais ce n'est plus obligatoire
            EXPECTED_KEYS=(
              "VITE_START_BAC5_42" "VITE_END_BAC5_42"
              "VITE_START_BAC2_GRETA" "VITE_END_BAC2_GRETA"
              "VITE_START_BAC2_CSFIEE" "VITE_END_BAC2_CSFIEE"
              "VITE_START_BAC_CSFIEE" "VITE_END_BAC_CSFIEE"
              "VITE_START_BAC_IPH" "VITE_END_BAC_IPH"
            )
            
            # 3. Ajouter les clÃ©s attendues
            for key in "${EXPECTED_KEYS[@]}"; do
              ALL_VITE_KEYS["$key"]=1
            done
            
            echo "Step 2: Processing ${#ALL_VITE_KEYS[@]} unique VITE_* key(s)..."
            echo ""
            
            # 4. Pour chaque clÃ©, appliquer la logique: vars â†’ secrets â†’ env
            for key in "${!ALL_VITE_KEYS[@]}"; do
              echo "ðŸ”§ Processing: $key"
              
              # La valeur par dÃ©faut (vide)
              final_value=""
              
              # LOGIQUE SIMPLIFIÃ‰E MAIS Ã‰QUIVALENTE:
              # Dans GitHub Actions, les variables sont dÃ©jÃ  injectÃ©es dans l'environnement
              # avec la prioritÃ© correcte si configurÃ©es dans l'interface GitHub
              # Donc on utilise simplement printenv
              
              current_value=$(printenv "$key" || echo "")
              
              if [ -n "$current_value" ]; then
                final_value="$current_value"
                echo "  âœ… Value found in environment"
              else
                echo "  âš ï¸  No value found (will be empty)"
              fi
              
              # Mise Ã  jour du .env.production
              # a. Supprimer la ligne existante
              if [ -f .env.production ]; then
                grep -v "^$key=" .env.production > .env.production.tmp 2>/dev/null || true
                if [ -f .env.production.tmp ]; then
                  mv .env.production.tmp .env.production
                else
                  touch .env.production
                fi
              fi
              
              # b. Ajouter la nouvelle ligne (mÃªme si vide)
              echo "$key=$final_value" >> .env.production
              
              echo ""
            done
            
            echo "âœ… Auto-injection completed!"
            echo "ðŸ“Š Summary: ${#ALL_VITE_KEYS[@]} variables processed"
          }
          
          # ExÃ©cuter la fonction
          auto_inject_vite_vars

      - name: Debug output (safe)
        run: |
          echo "=== Final .env.production VITE section ==="
          if [ -f .env.production ]; then
            grep -E '^VITE_' .env.production || echo "No VITE_* variables found"
            echo ""
            echo "Total VITE_* variables: $(grep -c '^VITE_' .env.production 2>/dev/null || echo 0)"
          fi
          sed -n 's/\r$//; /^VITE_/p' .env.production | while IFS= read -r kv; do
            key=$(echo "$kv" | sed -E 's/=.*//')
            val=$(echo "$kv" | sed -E 's/^[^=]*=//')
            len=$(echo -n "$val" | wc -c)
            echo "$key len=$len"
          done

      - name: Install dependencies (with lockfile)
        if: hashFiles('**/package-lock.json') != ''
        run: npm ci

      - name: Install dependencies (no lockfile)
        if: hashFiles('**/package-lock.json') == ''
        run: npm i

      - name: Build
        run: npm run build

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./dist

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        with: {}
      - name: Set environment URL output
        if: ${{ steps.deployment.outputs.page_url != '' }}
        run: echo "Deployed to ${{ steps.deployment.outputs.page_url }}"